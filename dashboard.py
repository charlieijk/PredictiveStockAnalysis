"""
Plotly Dash dashboard for the Predictive Stock Analysis project.

The dashboard loads the latest artifacts generated by the CLI pipeline and
renders price charts, model predictions, and performance tables. It is
designed so `main.py --dashboard` can import the `app` object without errors.
"""

from __future__ import annotations

import glob
import os
from datetime import datetime
from typing import Dict, List, Optional

import dash_bootstrap_components as dbc
import pandas as pd
import plotly.graph_objects as go
from dash import Dash, Input, Output, callback_context, dcc, html
from dash import dash_table

import config


# Refresh interval for the auto-update component (milliseconds)
AUTO_REFRESH_INTERVAL = config.DASHBOARD_CONFIG.get("auto_refresh_interval", 60) * 1000
GRAPH_CONFIG = {
    "displaylogo": False,
    "modeBarButtonsToRemove": [
        "sendDataToCloud",
        "lasso2d",
        "select2d",
        "autoScale2d",
        "resetScale2d",
    ],
    "responsive": True,
}


def _latest_file(pattern: str) -> Optional[str]:
    """Return the most recently modified file matching the pattern."""
    matches = glob.glob(pattern)
    if not matches:
        return None
    return max(matches, key=os.path.getmtime)


def _discover_symbols() -> List[str]:
    """Infer available symbols from saved raw data files."""
    files = glob.glob(os.path.join(config.DATA_DIR, "*_raw_data_*.csv"))
    symbols = set()
    for path in files:
        basename = os.path.basename(path)
        if "_raw_data_" in basename:
            symbols.add(basename.split("_raw_data_")[0])
    if not symbols:
        symbols.update(config.DATA_CONFIG.get("default_symbols", []))
    return sorted(symbols)


def load_symbol_artifacts(symbol: str) -> Dict[str, Optional[pd.DataFrame]]:
    """
    Load the most recent artifacts for a symbol.

    Returns:
        Dict with DataFrames (or None) for `raw`, `predictions`, and `comparison`.
    """
    raw_path = _latest_file(os.path.join(config.DATA_DIR, f"{symbol}_raw_data_*.csv"))
    pred_path = _latest_file(os.path.join(config.OUTPUT_DIR, f"{symbol}_predictions_*.csv"))
    comparison_path = _latest_file(
        os.path.join(config.OUTPUT_DIR, f"{symbol}_model_comparison_*.csv")
    )

    artifacts: Dict[str, Optional[pd.DataFrame]] = {"raw": None, "predictions": None, "comparison": None}

    if raw_path:
        df = pd.read_csv(raw_path)
        if "Date" in df.columns:
            df["Date"] = pd.to_datetime(df["Date"])
        artifacts["raw"] = df

    if pred_path:
        pred_df = pd.read_csv(pred_path)
        artifacts["predictions"] = pred_df

    if comparison_path:
        comp_df = pd.read_csv(comparison_path)
        artifacts["comparison"] = comp_df

    return artifacts


def _empty_figure(message: str) -> go.Figure:
    """Return a placeholder figure with a centered message."""
    fig = go.Figure()
    fig.add_annotation(
        text=message,
        xref="paper",
        yref="paper",
        x=0.5,
        y=0.5,
        showarrow=False,
        font=dict(size=16),
    )
    fig.update_layout(template="plotly_dark", xaxis_visible=False, yaxis_visible=False)
    return fig


def build_price_figure(df: Optional[pd.DataFrame], symbol: str) -> go.Figure:
    """Generate a line chart for OHLC data with optional moving averages."""
    if df is None or df.empty:
        return _empty_figure("Run the pipeline to generate price data.")

    fig = go.Figure()
    fig.add_trace(
        go.Scatter(
            x=df["Date"],
            y=df["Close"],
            mode="lines",
            name="Close",
            line=dict(color="#1f77b4", width=2),
        )
    )

    for col, color in zip(["SMA_20", "SMA_50", "SMA_200"], ["#ff7f0e", "#2ca02c", "#d62728"]):
        if col in df.columns:
            fig.add_trace(
                go.Scatter(
                    x=df["Date"],
                    y=df[col],
                    mode="lines",
                    name=col,
                    line=dict(dash="dash", color=color, width=1),
                )
            )

    fig.update_layout(
        template="plotly_dark",
        title=f"{symbol} Price & Moving Averages",
        xaxis_title="Date",
        yaxis_title="Price",
        hovermode="x unified",
    )
    return fig


def build_predictions_figure(pred_df: Optional[pd.DataFrame]) -> go.Figure:
    """Plot actual vs predicted values for each trained model."""
    if pred_df is None or pred_df.empty:
        return _empty_figure("Predictions not available yet.")

    fig = go.Figure()

    actual_df = (
        pred_df.sort_values(["Dataset", "Index"])
        .drop_duplicates(["Dataset", "Index"])
        .sort_values("Index")
    )
    if not actual_df.empty:
        fig.add_trace(
            go.Scatter(
                x=actual_df["Index"],
                y=actual_df["Actual"],
                mode="lines",
                name="Actual",
                line=dict(color="#ffffff", width=2),
            )
        )

    for model_name, group in pred_df.groupby("Model"):
        group_sorted = group.sort_values("Index")
        fig.add_trace(
            go.Scatter(
                x=group_sorted["Index"],
                y=group_sorted["Prediction"],
                mode="lines",
                name=model_name,
                line=dict(width=1),
            )
        )

    fig.update_layout(
        template="plotly_dark",
        title="Model Predictions vs Actual",
        xaxis_title="Index",
        yaxis_title="Return",
        hovermode="x unified",
    )
    return fig


def build_status_message(symbol: str, artifacts: Dict[str, Optional[pd.DataFrame]]) -> str:
    """Generate a textual status summary."""
    timestamps: List[str] = []
    for key, folder in [("raw", config.DATA_DIR), ("predictions", config.OUTPUT_DIR), ("comparison", config.OUTPUT_DIR)]:
        df = artifacts.get(key)
        pattern = ""
        if key == "raw":
            pattern = os.path.join(config.DATA_DIR, f"{symbol}_raw_data_*.csv")
        elif key == "predictions":
            pattern = os.path.join(config.OUTPUT_DIR, f"{symbol}_predictions_*.csv")
        elif key == "comparison":
            pattern = os.path.join(config.OUTPUT_DIR, f"{symbol}_model_comparison_*.csv")

        latest = _latest_file(pattern)
        if latest:
            ts = datetime.fromtimestamp(os.path.getmtime(latest)).strftime("%Y-%m-%d %H:%M")
            timestamps.append(f"{key.title()} updated {ts}")

    if not timestamps:
        return f"No saved artifacts found for {symbol}. Run `python main.py {symbol}` first."
    return " | ".join(timestamps)


def build_metric_cards(raw_df: Optional[pd.DataFrame], comparison_df: Optional[pd.DataFrame]) -> List[html.Div]:
    """Return styled metric cards summarizing the latest data."""
    cards: List[html.Div] = []

    if raw_df is not None and not raw_df.empty:
        last_close = raw_df["Close"].iloc[-1]
        prev_close = raw_df["Close"].iloc[-2] if len(raw_df) > 1 else last_close
        change = last_close - prev_close
        pct = (change / prev_close * 100) if prev_close else 0

        cards.append(
            html.Div(
                [
                    html.Span("Last Close", className="metric-label"),
                    html.H3(f"${last_close:,.2f}", className="metric-value"),
                    html.Span(f"{change:+.2f} ({pct:+.2f}%) vs prev close", className="metric-subtext"),
                ],
                className="metric-card",
            )
        )

        if "Volume" in raw_df.columns:
            avg_volume = raw_df["Volume"].tail(20).mean()
            cards.append(
                html.Div(
                    [
                        html.Span("Avg Volume (20d)", className="metric-label"),
                        html.H3(f"{avg_volume:,.0f}", className="metric-value"),
                        html.Span("Trailing 20 sessions", className="metric-subtext"),
                    ],
                    className="metric-card",
                )
            )

    if comparison_df is not None and not comparison_df.empty:
        best = comparison_df.sort_values("RMSE").iloc[0]
        cards.append(
            html.Div(
                [
                    html.Span("Best Model", className="metric-label"),
                    html.H3(best["Model"], className="metric-value"),
                    html.Span(f"RMSE {best['RMSE']:.4f} • Directional {best['Directional_Accuracy']:.2%}", className="metric-subtext"),
                ],
                className="metric-card",
            )
        )

    if not cards:
        cards.append(
            html.Div(
                [
                    html.Span("Awaiting Data", className="metric-label"),
                    html.H3("No artifacts yet", className="metric-value"),
                    html.Span("Run the CLI pipeline to populate the dashboard.", className="metric-subtext"),
                ],
                className="metric-card empty",
            )
        )

    return cards


symbol_options = _discover_symbols()
default_symbol = symbol_options[0] if symbol_options else "AAPL"
if not symbol_options:
    symbol_options = [default_symbol]

app = Dash(
    __name__,
    external_stylesheets=[dbc.themes.CYBORG],
    suppress_callback_exceptions=True,
)
app.title = "Predictive Stock Dashboard"

app.layout = html.Div(
    [
        html.Div(
            [
                html.Div(
                    [
                        html.H1("Predictive Stock Dashboard", className="app-title"),
                        html.P(
                            "Monitor the latest pipeline outputs, compare model performance, "
                            "and explore predicted vs. actual returns.",
                            className="app-subtitle",
                        ),
                    ],
                    className="title-block",
                ),
                html.Div(
                    [
                        html.Label("Symbol", className="control-label"),
                        dcc.Dropdown(
                            id="symbol-dropdown",
                            options=[{"label": sym, "value": sym} for sym in symbol_options],
                            value=default_symbol,
                            clearable=False,
                        ),
                        html.Button("Refresh Now", id="refresh-button", n_clicks=0, className="refresh-button"),
                    ],
                    className="control-panel",
                ),
            ],
            className="header",
        ),
        dcc.Interval(id="refresh-interval", interval=AUTO_REFRESH_INTERVAL, n_intervals=0),
        html.Div(id="dashboard-status", className="status-text"),
        html.Div(id="metric-cards", className="metric-grid"),
        dcc.Tabs(
            id="dashboard-tabs",
            value="charts",
            className="dashboard-tabs",
            children=[
                dcc.Tab(
                    label="Charts",
                    value="charts",
                    className="dashboard-tab",
                    selected_className="dashboard-tab--selected",
                    children=[
                        html.Div(
                            [
                                html.Div(
                                    dcc.Graph(
                                        id="price-chart",
                                        figure=_empty_figure("Select a symbol to view prices."),
                                        config=GRAPH_CONFIG,
                                    ),
                                    className="card chart-card",
                                ),
                                html.Div(
                                    dcc.Graph(
                                        id="predictions-chart",
                                        figure=_empty_figure("Predictions will appear here."),
                                        config=GRAPH_CONFIG,
                                    ),
                                    className="card chart-card",
                                ),
                            ],
                            className="chart-grid",
                        )
                    ],
                ),
                dcc.Tab(
                    label="Performance",
                    value="performance",
                    className="dashboard-tab",
                    selected_className="dashboard-tab--selected",
                    children=[
                        html.Div(
                            [
                                html.H3("Model Performance", className="section-title"),
                                dash_table.DataTable(
                                    id="comparison-table",
                                    columns=[
                                        {"name": "Model", "id": "Model"},
                                        {"name": "RMSE", "id": "RMSE"},
                                        {"name": "MAE", "id": "MAE"},
                                        {"name": "R2", "id": "R2"},
                                        {"name": "Directional Accuracy", "id": "Directional_Accuracy"},
                                    ],
                                    style_table={"overflowX": "auto"},
                                    style_cell={
                                        "backgroundColor": "#0c0f1a",
                                        "color": "#f2f4ff",
                                        "border": "none",
                                    },
                                    style_header={"fontWeight": "bold", "backgroundColor": "#11152b"},
                                    style_data_conditional=[
                                        {"if": {"row_index": "odd"}, "backgroundColor": "#0e182a"},
                                        {"if": {"row_index": "even"}, "backgroundColor": "#0b1321"},
                                    ],
                                    data=[],
                                ),
                            ],
                            className="card table-card",
                        )
                    ],
                ),
            ],
        ),
    ],
    className="app-container",
)


@app.callback(
    Output("price-chart", "figure"),
    Output("predictions-chart", "figure"),
    Output("comparison-table", "data"),
    Output("dashboard-status", "children"),
    Output("metric-cards", "children"),
    Input("symbol-dropdown", "value"),
    Input("refresh-interval", "n_intervals"),
    Input("refresh-button", "n_clicks"),
    prevent_initial_call=False,
)
def update_dashboard(symbol: str, _n_intervals: int, _n_clicks: int):
    """Refresh figures and tables when the symbol or timer changes."""
    triggered_by = callback_context.triggered[0]["prop_id"] if callback_context.triggered else "manual"
    artifacts = load_symbol_artifacts(symbol)

    price_fig = build_price_figure(artifacts["raw"], symbol)
    predictions_fig = build_predictions_figure(artifacts["predictions"])
    comparison_df = artifacts["comparison"]
    table_data: List[Dict[str, float]] = []

    if comparison_df is not None and not comparison_df.empty:
        table_data = comparison_df.to_dict("records")

    status_message = build_status_message(symbol, artifacts)
    if triggered_by.startswith("refresh-button"):
        status_message = f"Manual refresh • {status_message}"

    metric_cards = build_metric_cards(artifacts["raw"], comparison_df)

    return price_fig, predictions_fig, table_data, status_message, metric_cards


if __name__ == "__main__":
    app.run(
        debug=config.DASHBOARD_CONFIG.get("debug", True),
        host=config.DASHBOARD_CONFIG.get("host", "127.0.0.1"),
        port=config.DASHBOARD_CONFIG.get("port", 8050),
    )
